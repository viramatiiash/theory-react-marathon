// Інформація записана у local storage, sessional storage, cookies зберігається тільки у одному браузері, якщо ми відкриємо інший браузер, то тієї інформації там вже не буде.
// Local i session storage прекрасно підходять для зберігання не дуже важливої інформації - вподобання користувача, рахунки в іграх. Інформацію звідти легко дістати, тому краще нічого важливого там не зберігати, причому, користувач сам може почистити кеш. Cookies трохи безпечніший, особливо використовується для зберігання авторизаційних даних.

// Local storage i cookies зберігаються для будь-якого таба чи вікна браузера.  Local Storage не має визначеного терміну життя, дані можуть бути видалені у програмному коді. Максимальний розмір даних - 10мб.cookies налаштовується вручну, їм можна вказати expiration date.Дані, записані у cookies посилаються на сервер, тому розмір даних не має перевищувати 4кб.

// session storage тільки для таба і вмирає при його закритті, тобто, закриваємо вікно чи браузер - session storage кінець. При перезавантаженні сторінки живе далі. Розмір даних - 5мб.



// ! Local Storage
localStorage.setItem('course', 'React'); // 'course' - ключ, 'React' - значення.
console.log(localStorage.getItem('course')); // вказуємо ключ, щоб достукатися до значення, що записане на localStorage.
localStorage.removeItem('course'); // видаляємо значення
localStorage.setItem('course', 'node'); // значення перезаписується

// ! Session Storage
sessionStorage.setItem('type', 'marathon'); // Session storage має такий самий набір методів, як і у local storage/
console.log(sessionStorage.getItem('type'));
sessionStorage.removeItem('type');
sessionStorage.setItem('type', 'internship');

// ! Cookies
document.cookie = 'name=Car'; // name - ключ, Car - значення
// Cookie буде жити тільки скільки живе сесія.
// document.cookie = 'name=Car; expires=' + new Date(2024, 0, 1); // 0 - нульовий місяць, тобто січень
document.cookie = 'name=Car; expires=Mon, 05 Aug 2024 23:00:00UTC'; // 0 - нульовий місяць, тобто січень

document.cookie = 'OtherName=Express; expires=' + new Date(9999, 0, 1); // чомусь немає дати 9999, все завершується 2024 роком, не доходячи до 2025. Але значення cookies не перезаписуються, а конкатинуються, додаються.

// ________________________________________________________________________________________________________________
// ! Web Worker
// Він дозволяє виконувати довготривалі і складні таски, не блокуючи user interface. Код вебворкера має зберігатися у окремому файлі, тому що це окремий, ізольований потік. Він не має доступу до window i document objects. Вебворкер не може напряму змінювати user interface. Він використовується, поки дані завантажуються, великому кешуванні даних, аналіз відео/аудіо/тексту за різними критеріями, шифрування
// Взаємодія між основним потоком веб-сторінки і потоком вебворкера відбувається на основі системи івентів і передачі повідомлень.
// .postMessage(data) - метод для передачі даних, параметром якого є дані, які мають бути передані.
// 'message' - івент, який використовується для отримання даних
// ? Вище названий метод і івент використовується як головним потоком, так і вебворкером. Якщо головний потік хоче надіслати повідомлення на вебворкер, то там використовується метод .postMessage(data), якщо з вебворкера треба надіслати повідомлення, навпаки, на головний потік, тоді там також використовується цей метод.
// Є два варіанти, як зупинити вебворкер:
// terminate() - метод, що викликається на головному потоці веб-сторінки
// close() - метод, що викликається всередині вебворкера

// ! Файли index.js, worker.js i index.html мусять бути поміщені на будь-який доступний сервер. Якщо запустити код без сервера, прямо у браузері, то вебворкер не буде працювати.

// Поки працює вебворкер можуть виникати помилки. Опрацювання помилок відбувається через івент 'error'. У його обробник можуть бути передані такі властивості:
// 1. filename - ім'я файлу, у якому якийсь скрипт спричинив помилку
// 2. lineno - номер рядка, де сталась помилка
// 3. message - опис помилки
const w = new Worker('worker.js');
w.addEventListener('error', (e) => {
  console.log('File:', e.filename);
  console.log('Error in', e.lineno, 'line');
  console.log('Message:', e.message);
});
w.postMessage('Hello Worker!');

const worker = new Worker('worker.js'); // створюємо об'єкт Worker, у дужках пишемо посилання на файл, де він буде зберігатися. Якщо такого файлу не існує, то видасть помилку 404 і об'єкт не створиться.

worker.onmessage = data => {
  console.log('Worker sent', data);
} // і головний скрипт, і воркер очікують на інформацію одне від одного

// worker.postMessage('Hello from main script!'); // головний скрипт надсилає повідомлення воркеру

// ! Наступний код у веб воркері
// let count = 0;
// const now = performance.now();
// for (let i = 0; i < 2000000000; i++){
//   count++;
// }

// console.log('Time of execution is', performance.now() - now);

// alert('UI нарешті вільний');
// // якщо виконується попередній код, то ui блокується.


worker.postMessage({ type: 'command' });
    alert('UI нарешті вільний'); // Таким чином UI буде вільний відразу, незалежно від часу виконання.


